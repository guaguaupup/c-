#  c++单例模式

> 定义：单例模式是创建型设计模式，指的是在系统的生命周期中只能产生一个实例(对象)，确保该类的唯一性。
>
> 一般遇到的写进程池类、日志类、内存池（用来缓存数据的结构，在一处写多出读或者多处写多处读）的话都会用到单例模式

**实现方法：**全局只有一个实例也就意味着不能用new调用构造函数来创建对象，因此构造函数必须是虚有的。但是由于不能new出对象，所以类的内部必须提供一个函数来获取对象，而且由于不能外部构造对象，因此这个函数不能是通过对象调出来，换句话说这个函数应该是属于对象的，很自然我们就想到了用static。由于静态成员函数属于整个类，在类实例化对象之前就已经分配了空间，而类的非静态成员函数必须在类实例化后才能有内存空间。

单例模式的要点总结：

1. 全局只有一个实例，用static特性实现，构造函数设为私有
2. 通过公有接口获得实例
3. 线程安全
4. 禁止拷贝和赋值

单例模式可以**分为懒汉式和饿汉式**，两者之间的区别在于创建实例的时间不同：懒汉式指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例(这种方式要考虑线程安全)。饿汉式指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）

## 懒汉式

- 普通懒汉式会让线程不安全

  因为不加锁的话当线程并发时会产生多个实例，导致线程不安全

  ```c++
  ///  普通懒汉式实现 -- 线程不安全 //
  #include <iostream> // std::cout
  #include <mutex>    // std::mutex
  #include <pthread.h> // pthread_create
  
  class SingleInstance
  {
  public:
      // 获取单例对象
      static SingleInstance *GetInstance();
      // 释放单例，进程退出时调用
      static void deleteInstance();
  	// 打印单例地址
      void Print();
  private:
  	// 将其构造和析构成为私有的, 禁止外部构造和析构
      SingleInstance();
      ~SingleInstance();
      // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值
      SingleInstance(const SingleInstance &signal);
      const SingleInstance &operator=(const SingleInstance &signal);
  private:
      // 唯一单例对象指针
      static SingleInstance *m_SingleInstance;
  };
  
  //初始化静态成员变量
  SingleInstance *SingleInstance::m_SingleInstance = NULL;
  
  SingleInstance* SingleInstance::GetInstance()
  {
  	if (m_SingleInstance == NULL)
  	{
  		m_SingleInstance = new (std::nothrow) SingleInstance;  // 没有加锁是线程不安全的，当线程并发时会创建多个实例
  	}
      return m_SingleInstance;
  }
  
  void SingleInstance::deleteInstance()
  {
      if (m_SingleInstance)
      {
          delete m_SingleInstance;
          m_SingleInstance = NULL;
      }
  }
  
  void SingleInstance::Print()
  {
  	std::cout << "我的实例内存地址是:" << this << std::endl;
  }
  
  SingleInstance::SingleInstance()
  {
      std::cout << "构造函数" << std::endl;
  }
  
  SingleInstance::~SingleInstance()
  {
      std::cout << "析构函数" << std::endl;
  }
  ///  普通懒汉式实现 -- 线程不安全  //
  ```

- 线程安全、内存安全的懒汉式

  上述代码出现的问题：

  1. GetInstance()可能会引发竞态条件，第一个线程在if中判断 `m_instance_ptr`是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断`m_instance_ptr`还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来

     解决办法：①加锁。②局部变量实例

  2. 类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏。

     解决办法：使用共享指针

  > c++11标准中有一个特性：如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。因此这种懒汉式是最推荐的，因为：
  >
  > 1. 通过局部静态变量的特性保证了线程安全 (C++11, GCC > 4.3, VS2015支持该特性);
  > 2. 不需要使用共享指针和锁
  > 3. get_instance()函数要返回引用而尽量不要返回指针，

  ```c++
  ///  内部静态变量的懒汉实现  //
  class Singleton
  {
  public:
      ~Singleton(){
          std::cout<<"destructor called!"<<std::endl;
      }
      //或者放到private中
      Singleton(const Singleton&)=delete;
      Singleton& operator=(const Singleton&)=delete;
      static Singleton& get_instance(){
          //关键点！
          static Singleton instance;
          return instance;
      }
      //不推荐，返回指针的方式
      /*static Singleton* get_instance(){
          static Singleton instance;
          return &instance;
  	}*/
  private:
      Singleton(){
          std::cout<<"constructor called!"<<std::endl;
      }
  };
  
  ```

  > 使用锁、共享指针实现的懒汉式单例模式
  >
  > - 基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。
  > - 加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为**双检锁**；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。
  >
  > 不足之处在于： 使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; 使用锁也有开销; 同时代码量也增多了，实现上我们希望越简单越好。

  ```c++
  #include <iostream>
  #include <memory> // shared_ptr
  #include <mutex>  // mutex
  
  // version 2:
  // with problems below fixed:
  // 1. thread is safe now
  // 2. memory doesn't leak
  
  class Singleton {
  public:
      typedef std::shared_ptr<Singleton> Ptr;
      ~Singleton() {
          std::cout << "destructor called!" << std::endl;
      }
      Singleton(Singleton&) = delete;
      Singleton& operator=(const Singleton&) = delete;
      static Ptr get_instance() {
  
          // "double checked lock"
          if (m_instance_ptr == nullptr) {
              std::lock_guard<std::mutex> lk(m_mutex);
              if (m_instance_ptr == nullptr) {
                  m_instance_ptr = std::shared_ptr<Singleton>(new Singleton);
              }
          }
          return m_instance_ptr;
      }
  
  
  private:
      Singleton() {
          std::cout << "constructor called!" << std::endl;
      }
      static Ptr m_instance_ptr;
      static std::mutex m_mutex;
  };
  
  // initialization static variables out of class
  Singleton::Ptr Singleton::m_instance_ptr = nullptr;
  std::mutex Singleton::m_mutex;
  ```

  

## 饿汉式

```c++

// 饿汉实现 /
class Singleton
{
    
public:
    // 获取单实例
    static Singleton* GetInstance();
    // 释放单实例，进程退出时调用
    static void deleteInstance();
    // 打印实例地址
    void Print();

private:
    // 将其构造和析构成为私有的, 禁止外部构造和析构
    Singleton();
    ~Singleton();

    // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值
    Singleton(const Singleton &signal);
    const Singleton &operator=(const Singleton &signal);

private:
    // 唯一单实例对象指针
    static Singleton *g_pSingleton;
};

// 代码一运行就初始化创建实例 ，本身就线程安全
Singleton* Singleton::g_pSingleton = new (std::nothrow) Singleton;

Singleton* Singleton::GetInstance()
{
    return g_pSingleton;
}

void Singleton::deleteInstance()
{
    if (g_pSingleton)
    {
    
        delete g_pSingleton;
        g_pSingleton = NULL;
    }
}

void Singleton::Print()
{
    std::cout << "我的实例内存地址是:" << this << std::endl;
}

Singleton::Singleton()
{
    std::cout << "构造函数" << std::endl;
}

Singleton::~Singleton()
{
    std::cout << "析构函数" << std::endl;
}
// 饿汉实现 /
```

## 面试题

- 懒汉模式和恶汉模式的实现（判空！！！加锁！！！），并且要能说明原因（为什么判空两次？）
- 构造函数的设计（为什么私有？除了私有还可以怎么实现（进阶）？）
- 对外接口的设计（为什么这么设计？）
- 单例对象的设计（为什么是static？如何初始化？如何销毁？（进阶））
- 对于C++编码者，需尤其注意C++11以后的单例模式的实现（为什么这么简化？怎么保证的（进阶））



# 工厂模式

# MVC模式
