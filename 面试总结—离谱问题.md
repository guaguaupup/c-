# **ubuntu开机的时候系统做了什么？**

1）加载BIOS

​	    因为ROM的发明，开机程序会被刷入ROM中。当计算机通电的时候，首先读取ROM。

​		ROM里面的程序叫做**基本输入输出系统（BIOS）**

​		BIOS首先“硬件自检”，查看硬件是否能够工作。完成后BIOS把权限交给启动程序，用来对启动设备进行排序，依次启动

2）读取MBR

​		BIOS首先把控制权交给存储设备。系统会读取该设备的最前面512字节，如果最后两个字节分别是0x55和0xAA则表示可以启动，然后把控制权交给下一个设备

​		存储设备最前面的512个叫做**主引导记录（MBR）**，由三部分组成：

​				①1-446字节，调用操作系统的机器码

​				②447-510字节，分区表

​				③511-512字节，主引导记录签名（0x55和0xAA）

3）Bootloader

​		 Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。Linux环境中，目前最流行的启动管理器是 Grub。

4）加载内核

​		内核加载后，接开始操作系统初始化，根据进程的优先级启动进程，这时候linux操作系统已经可以运行了

5）用户层init依据inittab文件来设定运行等级

​		<img src="https://s2.loli.net/2022/01/18/Fg8kXYQtSjJ6uVx.png" alt="img" style="zoom: 80%;" />



# 都有那些编程范式？

- 面向过程（Process Oriented Programming，POP）

  最原始，也是我们最熟悉的一种编程语言。他的编程思维源自于计算机指令的顺序排列。

  步骤：首先将待解决的问题抽象为一系列概念化的步骤。然后一步一步的按照顺序实现所有步骤。

  优点：流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。

  缺点：需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。

- 面向对象（Object Oriented Programming，OOP）

  所有事物都是对象。易于维护，扩展和复用

  优点:结构清晰，程序是模块化和结构化，更加符合人类的思维方式；易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；易维护，系统低耦合的特点有利于减少程序的后期维护工作量。

  缺点：开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。

  性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。

  > 举个例子：下五子棋
  >
  > 面向过程：开始游戏（）；
  > 黑子先走（）；
  > 绘制画面（）；
  > 判断输赢（）；
  > 轮到白子（）；
  > 绘制画面（）；
  > 判断输赢（）；
  > 返回到 黑子先走（）；
  > 输出最后结果；
  >
  > 面向对象：黑白双方，这两方的行为是一样的。棋盘系统，负责绘制画面。规则系统，负责判定犯规、输赢等。

- 事件驱动编程

  主要是用在图形用户界面，比如C#这种

  功能都是提前写好的，就等着触发

- 面向接口（Interface Oriented Programming， IOP）

- 面向切面（Aspect Oriented Programming，AOP）

- 函数式（Funtional Programming，FP）

- 响应式（Reactive Programming，RP）

- 数响应式（Functional Reactive Programming，FRP）

  

# 为什么malloc分配内存需要传入大小，而free释放不需要？



# SYN报文什么情况下会被丢弃

[参考链接](https://mp.weixin.qq.com/s/2xkYbczdHKgpUnicBw0pkA)



# 计算机内核态和用户态概念懂吧，给我讲讲，把我当做小白。

# DDoS是什么

# 时延，丢包，抖动



# c语言怎么实现多态

# [科学上网的原理](https://woaifanqiang.com/post/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E5%8E%9F%E7%90%86/#%E8%83%8C%E6%99%AF)



# 软件开发模型

## 瀑布模型

## 敏捷开发模型

## scrum开发模型

scrum的团队不需要那么大，十几个人即可。

> **下面先给出scrum的模型：**
>
> <img src="http://image.woshipm.com/wp-files/2017/09/z7yrIA5t0m3jjwEYlJll.png" alt="img" style="float: left;" />



**scrum所包含的角色**

1. PO：Product Owner，产品负责人，确定「大家要做什么」。互联网公司的 PO 一般由相关的产品经理担任；如果是为客户做项目，PO 就是客户负责人。
2. Scrum Master：Scrum的推动者，掌控大节奏的人。
3. Scrum Team ：Developer，开发的主力。

三种角色有各自的责任，但三者间并没有上司和下属的关系。这正是 Scrum 区别于传统开发流程的精华：

- 传统的开发流程，是由领导拍板的中央集权制；
- Scurm 是人人平等的民主制，每个人的能力都被信任，更加自主，能发挥出更高的效率。



**scrum的一些名词**

1. Sprint：周期指的是一次迭代，而一次迭代的周期一般是2-4周，也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。
2. Backlog ：待办工作事项的集合。
3. Product Backlog ：PO将产品待办事项列表放入，是量化的用户需求，条目化地表达实际需要开发的需求。一般来说这个是以sprint来计算
4.  Sprint Backlog：任务列表。是一次迭代中需要完成的任务，也是开发过程用得最多的Backlog，非常细化。一般来说以天来计算。



**如何进行Scrum开发？**

1. 我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；
2. Scrum Team根据Product Backlog列表，做工作量的预估和安排；
3. 有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期（intel我们组是2周），然后把这个Story进行细化，形成一个Sprint Backlog；
4. Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；
5. 在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；
6. 做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；
7. 当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；
8. 最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；
